#!/bin/bash


function _chroot_run()
{
    eval -- arch-chroot "${ROOTFS_DIR}" "${RUN_CMD}"
}

function _mount_rootfs()
{
    trap "_umount_airootfs" EXIT HUB INT TERM
    msg_info "install -d -m 0755 -- ${WORK_DIR}/mnt/airootfs"
    install -d -m 0755 -- "${WORK_DIR}/mnt/airootfs"
    msg_info "mount -- ${ROOTFS_DIR}.img ${WORK_DIR}/mnt/airootfs"
    mount -- "${ROOTFS_DIR}.img" "${WORK_DIR}/mnt/airootfs"
}


# 创建镜像
function _make_rootfs_create_image()
{
    if (( $# < 1 )); then
        msg_error "函数 '${FUNCNAME[0]}' 至少需要一个参数" 1
    fi

    imagePath="${ISO_DIR}/${APP_NAME}/${ARCH}/airootfs.sfs"
    if [[ "${ROOTFS_IMAGE_TYPE}" =~ .*squashfs ]] ; then
        msg_info "mksquashfs $@ ${imagePath} -noappend ${ROOTFS_IMAGE_TOOL_OPTIONS[@]}"
        mksquashfs "$@" "${imagePath}" -noappend "${ROOTFS_IMAGE_TOOL_OPTIONS[@]}"
    else
        msg_error "不支持的镜像类型: '${ROOTFS_IMAGE_TYPE}'" 1
    fi
}

# 从源目录在SquashFS中创建ext4文件系统
function _make_rootfs_img()
{
    if [[ ! -e "${ROOTFS_DIR}" ]]; then
        msg_error "'${ROOTFS_DIR}' 路径不存在" 1
    fi

    msg_info "开始创建一个 32GB 的 ext4 镜像 ..."
    msg_info "mkfs.ext4 -O '^has_journal,^resize_inode' -E 'lazy_itable_init=0' -m 0 -F -- ${ROOTFS_DIR}.img 32G"
    mkfs.ext4 -O '^has_journal,^resize_inode' -E 'lazy_itable_init=0' -m 0 -F -- "${ROOTFS_DIR}.img" 32G

    msg_info "tune2fs -c 0 -i 0 -- ${ROOTFS_DIR}.img > /dev/null"
    tune2fs -c 0 -i 0 -- "${ROOTFS_DIR}.img" > /dev/null

    _mount_rootfs
    msg_info "正在复制 '${ROOTFS_DIR}/' 到 '${WORK_DIR}/mnt/airootfs/'..."
    msg_info "cp -aT -- ${ROOTFS_DIR}/  ${WORK_DIR}/mnt/airootfs/"
    cp -aT -- "${ROOTFS_DIR}/" "${WORK_DIR}/mnt/airootfs/"
    msg_info "chown -- 0:0  ${WORK_DIR}/mnt/airootfs/"
    chown -- 0:0 "${WORK_DIR}/mnt/airootfs/"
    _umount_rootfs

    install -d -m 0755 -- "${WORK_DIR}/${INSTALL_DIR}/${ARCH}"
    msg_info "正在创建 SquashFS 镜像, 可能需要花点时间 ..."
    _make_rootfs_create_image "${ROOTFS_DIR}"

    msg_info "rm -- ${ROOTFS_DIR}.img"
    rm -- "${ROOTFS_DIR}.img"
}

function _make_rootfs_sfs()
{
    if [[ ! -e "${ROOTFS_DIR}" ]]; then
        msg_error "'${ROOTFS_DIR}' 路径不存在" 1
    fi

    install -d -m 0755 -- "${ISO_DIR}/${APP_NAME}/${ARCH}"
    msg_info "正在创建 SquashFS 镜像, 这可能需要花点时间 ..."
    _make_rootfs_create_image "${ROOTFS_DIR}"
}

function _mkchecksum()
{
    cd -- "${ISO_DIR}/${APP_NAME}/${ARCH}"
    chmod 0777 "${ISO_DIR}/${APP_NAME}/${ARCH}"
    msg_info "sha512sum airootfs.sfs > airootfs.sha512"
    sha512sum airootfs.sfs > airootfs.sha512
    cd -- "${OLDPWD}"
}

function _mksignature()
{
    msg_info "开始给 SquashFS 镜像签名 ..."
    msg_info "cd -- ${ISO_DIR}/${APP_NAME}/${ARCH}"
    cd -- "${ISO_DIR}/${APP_NAME}/${ARCH}"
    sudo -u ${SUDO_USER} gpg --detach-sign --default-key "${GPG_KEY}" airootfs.sfs
    cd -- "${OLDPWD}"
}

function _pacman()
{
    msg_info "正在安裝軟件包到 '${ROOTFS_DIR}/' ..."
    pacstrap -C "${WORK_DIR}/pacman.conf" -c -G -M -- "${ROOTFS_DIR}" "$@"
    msg_info "所有軟件包安裝完成!!!"
}

function check_is_root()
{
    if (( EUID != 0 )); then
        msg_error "必须以 root 运行." 1
    fi
}


function show_config
{
    local BUILD_DATE
    BUILD_DATE="$(date --utc --iso-8601=seconds -d "@${SOURCE_DATE_EPOCH}")"
    msg_info_pure "${APP_NAME} 配置值如下："
    msg_info_pure "             架构:       ${ARCH}"
    msg_info_pure "         工作目录:       ${WORK_DIR}"
#    msg_info_pure "         安装目录:       ${INSTALL_DIR}"
    msg_info_pure "         构建时间:       ${BUILD_DATE}"
#    msg_info_pure "       输出文件夹:       ${OUT_DIR}"
    msg_info_pure "         GPG 指纹:       ${GPG_KEY:-None}"
    msg_info_pure "         配置文件:       ${PROFILE}"
    msg_info_pure "  pacman 配置文件:       ${PACMAN_CONF}"
    msg_info_pure "       镜像文件名:       ${ISO_NAME}"
    msg_info_pure "       ISO 卷标签:       ${ISO_LABEL}"
    msg_info_pure "       ISO 出版者:       ${ISO_PUBLISHER}"
    msg_info_pure "         ISO 名字:       ${ISO_APPLICATION}"
    msg_info_pure "         引导模式:       ${BOOT_MODULES[*]}"
    msg_info_pure "       要安裝的包:       ${PKG_LIST[*]}"
}

function make_pacman_conf()
{
    local CACHE_DIR SYS_CACHE_DIR PROFILE_CACHE_DIR
    SYS_CACHE_DIR="$(pacman-conf CacheDir| tr '\n' ' ')"
    PROFILE_CACHE_DIR="$(pacman-conf --config "${PACMAN_CONF}" CacheDir| tr '\n' ' ')"

    install --mode=0777 -d "${WORK_DIR}"
   
    # 设置缓存目录
   if [[ "${PROFILE_CACHE_DIR}" != "/var/cache/pacman/pkg" ]] && \
       [[ "${SYS_CACHE_DIR}" != "${PROFILE_CACHE_DIR}" ]]; then
       CACHE_DIR="${PROFILE_CACHE_DIR}"
   else
       CACHE_DIR="${SYS_CACHE_DIR}"
   fi
   
   pacman-conf --config "${PACMAN_CONF}" | \
       sed '/CacheDir/d;/DBPath/d;/HookDir/d;/LogFile/d;/RootDir/d' > "${WORK_DIR}/pacman.conf"
   
   sed "/\[options\]/a CacheDir = ${CACHE_DIR}
        /\[options\]/a HookDir = ${ROOTFS_DIR}/etc/pacman.d/hooks/" \
            -i "${WORK_DIR}/pacman.conf"
}

function export_gpg_public_key()
{
    if [[ -n "${GPG_KEY}" ]]; then
        [[ ! -f "${WORK_DIR}/pubkey.gpg" ]] && sudo -u ${SUDO_USER} gpg --batch --output "${WORK_DIR}/pubkey.gpg" --export "${GPG_KEY}"
    fi
}

function make_custom_rootfs()
{
    local passwd=()

    install -d -m 0755 -o 0 -g 0 -- "${ROOTFS_DIR}"

    if [[ -d "${DIR_CONF}/rootfs" ]]; then
        cp -af --no-preserve=ownership -- "${DIR_CONF}/rootfs/." "${ROOTFS_DIR}"

        [[ -e "${ROOTFS_DIR}/etc/shadow" ]]  && chmod -f 0400 -- "${ROOTFS_DIR}/etc/shadow"
        [[ -e "${ROOTFS_DIR}/etc/gshadow" ]] && chmod -f 0400 -- "${ROOTFS_DIR}/etc/gshadow"

        if [[ -e "${ROOTFS_DIR}/etc/passwd" ]]; then
            while IFS=':' read -a passwd -r; do
                [[ "${passwd[5]}" == '/' ]] && continue
                [[ -z "${passwd[5]}" ]] && continue

                if [[ -d "${ROOTFS_DIR}${passwd[5]}" ]]; then
                    chown -hR -- "${passwd[2]}:${passwd[3]}" "${ROOTFS_DIR}${passwd[5]}"
                    chmod -f 0750 -- "${ROOTFS_DIR}${passwd[5]}"
                else
                    install -d -m 0750 -o "${passwd[2]}" -g "${passwd[3]}" -- "${ROOTFS_DIR}${passwd[5]}"
                fi
            done < "${ROOTFS_DIR}/etc/passwd"
        fi
    fi
}

function make_packages()
{
    if [[ -n "${GPG_KEY}" ]]; then
        exec {ISO_GNUPG_FD}<>"${WORK_DIR}/pubkey.gpg"
        export ISO_GNUPG_FD
    fi

    _pacman "${PKG_LIST[@]}"
    if [[ -n "${GPG_KEY}" ]]; then
        exec {ISO_GNUPG_FD}<&-
        unset ISO_GNUPG_FD
    fi
}

function make_customize_rootfs()
{
    local passwd=()

    if [[ -e "${ROOTFS_DIR}/etc/passwd" ]]; then
        while IFS=':' read -a passwd -r; do
            (( passwd[2] >= 1000 && passwd[2] < 60000 )) || continue
            [[ "${passwd[5]}" == '/' ]] && continue
            [[ -z "${passwd[5]}" ]] && continue
            cp -dnRT --preserve=mode,timestamps,links -- "${ROOTFS_DIR}/etc/skel" "${ROOTFS_DIR}${passwd[5]}"
            chmod -f 0750 -- "${ROOTFS_DIR}${passwd[5]}"
            chown -hR -- "${passwd[2]}:${passwd[3]}" "${ROOTFS_DIR}${passwd[5]}"
        done < "${ROOTFS_DIR}/etc/passwd"
    fi
   
    if [[ -e "${ROOTFS_DIR}/root/customize-gracefullinux.sh" ]]; then
        local RUN_CMD="/root/customize-gracefullinux.sh"
        chroot_run
        rm -- "${ROOTFS_DIR}/root/customize-gracefullinux.sh"
    fi
}

function make_pkg_list()
{
    install -d -m 0755 -- "${WORK_DIR}"
    pacman -Q --sysroot ${ROOTFS_DIR} > ${WORK_DIR}/pkglist.${ARCH}.txt
}

function make_boot_modes()
{
    local bootmode
    for bootmode in "${BOOT_MODES[@]}"; do
        if typeset -f "make_boot_${bootmode}" &> /dev/null; then
            run_once "make_boot_${bootmode}"
        else
            msg_error "无效的 boot 模式: ${bootmode}" 1
        fi
    done
}

function make_cleanup()
{
    # 删除 /boot 下的文件
    if [[ -d "${ROOTFS_DIR}/boot" ]]; then
        find "${ROOTFS_DIR}/boot" -mindepth 1 -delete
    fi

    # 删除 pacman 数据库缓冲下的包文件 (*.tar.gz)
    if [[ -d "${ROOTFS_DIR}/var/lib/pacman" ]]; then
        find "${ROOTFS_DIR}/var/lib/pacman" -maxdepth 1 -type f -delete
    fi

    # 删除 pacman 数据库缓冲
    if [[ -d "${ROOTFS_DIR}/var/lib/pacman/sync" ]]; then
        find "${ROOTFS_DIR}/var/lib/pacman/sync" -delete
    fi

    # 删除 pacman 包缓冲
    if [[ -d "${ROOTFS_DIR}/var/cache/pacman/pkg" ]]; then
        find "${ROOTFS_DIR}/var/cache/pacman/pkg" -type f -delete
    fi

    # 删除所有的日志文件
    if [[ -d "${ROOTFS_DIR}/var/log" ]]; then
        find "${ROOTFS_DIR}/var/log" -type f -delete
    fi

    # 删除临时文件
    if [[ -d "${ROOTFS_DIR}/var/tmp" ]]; then
        find "${ROOTFS_DIR}/var/tmp" -mindepth 1 -delete
    fi

    # 删除 pacman 相关的文件
    find "${WORK_DIR}" \( -name '*.pacnew' -o -name '*.pacsave' -o -name '*.pacorig' \) -delete

    # 创建一个空的 /etc/matchine-id
    printf '' > "${ROOTFS_DIR}/etc/machine-id"
}

function make_prepare()
{
    if [[ "${ROOTFS_IMAGE_TYPE}" == "squashfs" ]]; then                 # prepare airootfs.sfs for overlayfs usage (default)
        run_once _make_rootfs_sfs
    elif [[ "${ROOTFS_IMAGE_TYPE}" == "ext4+squashfs" ]]; then          # prepare airootfs.sfs for dm-snapshot usage
        run_once _make_rootfs_img
    else
        msg_error "不支持的镜像类型: '${ROOTFS_IMAGE_TYPE}'" 1
    fi
    
    _mkchecksum
    
    if [[ "${GPG_KEY}" ]]; then
        _mksignature
    fi
}

# Build ISO
function make_iso()
{
    local xorrisofs_options=()

    for bootmode in "${bootmodes[@]}"; do
        typeset -f "_add_xorrisofs_options_${bootmode}" &>/dev/null && "_add_xorrisofs_options_${bootmode}"
    done

    msg_info "开始创建 ISO 镜像 ..."
    rm -f "${WORK_DIR}/${ISO_NAME_FULL}"
    xorriso -as mkisofs \
        -v \
        -iso-level 3 \
        -full-iso9660-filenames \
        -joliet \
        -joliet-long \
        -rational-rock \
        -volid "${ISO_LABEL}" \
        -appid "${ISO_APPLICATION}" \
        -publisher "${ISO_PUBLISHER}" \
        -preparer "${APP_NAME}" \
        "${xorrisofs_options[@]}" \
        -output "${WORK_DIR}/${ISO_NAME_FULL}" \
        ${ISO_DIR}
    msg_info "完成!"
    du -h -- "${WORK_DIR}/${ISO_NAME_FULL}"
}


